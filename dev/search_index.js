var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [HSL]","category":"page"},{"location":"reference/#HSL.Ma57","page":"Reference","title":"HSL.Ma57","text":"Instantiate an object of type Ma57 and perform the symbolic analysis on a sparse Julia matrix.\n\nM = Ma57(A; kwargs...)\n\nInput arguments\n\nA::SparseMatrixCSC{T<:Ma57Data,Int}: input matrix. The lower triangle will be extracted.\n\nKeyword arguments\n\nAll keyword arguments are passed directly to ma57_coord().\n\nStored information:\n\nM.info.largest_front::Int: order of largest frontal matrix\nM.info.num_2x2_pivots::Int: number of 2x2 pivots used in factorization\nM.info.num_delayed_pivots::Int: total number of fully-summed variables that were passed to the father node because of pivoting considerations\nM.info.num_negative_eigs::Int: number of negative eigenvalues in factorization of M\nM.info.rank::Int: rank of factorization of M\nM.info.num_pivot_sign_changes::Int: number of sign changes of pivot when icntl(7) = 3 (ie, no pivoting)\n\nExample:\n\njulia> T = Float64;\njulia> rows = Cint[1, 2, 3, 5, 3, 4, 5]; cols = Cint[1, 1, 2, 2, 3, 3, 5];\njulia> vals = T[2, 3, 4, 6, 1, 5, 1];\njulia> A = sparse(rows, cols, vals);\njulia> M = Ma57(A)\nHSL.Ma57{Float64}(5, 7, Cint[1, 1, 2, 2, 3, 3, 5], Cint[1, 2, 3, 5, 3, 4, 5], [2.0, 3.0, 4.0, 6.0, 1.0, 5.0, 1.0], HSL.Ma57_Control{Float64}(Cint[6, 6, 6, -1, 0, 5, 1, 0, 10, 1, 16, 16, 10, 100, 1, 0, 0, 0, 0, 0], [0.01, 1.0e-20, 0.5, 0.0, 0.0]), HSL.Ma57_Info{Float64}(Cint[0, 0, 0, 0, 12, 13, 4, 2, 48, 53  …  0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [10.0, 34.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 0, 0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0), 1.1, 81, Cint[5, 4, 3, 2, 1, 2, 9, 0, 0, 0  …  4, 3, 3, 2, 2, 1, 1, 0, 0, 0], 48, Float64[], 53, Cint[])\n\n\n\n\n\n","category":"type"},{"location":"reference/#HSL.Ma57Exception","page":"Reference","title":"HSL.Ma57Exception","text":"Exception type raised in case of error.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HSL.Ma57_Control","page":"Reference","title":"HSL.Ma57_Control","text":"Main control type for MA57.\n\nMa57_Control(; kwargs...)\n\nKeyword arguments:\n\nsqd::Bool: Flag indicating symmetric quasi-definite matrix (default: false)\nprint_level::Int: integer controling the verbosit level. Accepted values are:\n<0: no printing\n0: errors and warnings only (default)\n1: errors, warnings and basic diagnostics\n2: errors, warning and full diagnostics\nunit_diagnostics::Int: Fortran file unit for diagnostics (default: 6)\nunit_error::Int: Fortran file unit for errors (default: 6)\nunit_warning::Int: Fortran file unit for warnings (default: 6)\n\nExample:\n\njulia> using HSL\njulia> Ma57_Control{Float64}(print_level=1)\nHSL.Ma57_Control{Float64}(Cint[6, 6, 6, -1, 1, 5, 1, 0, 10, 1, 16, 16, 10, 100, 1, 0, 0, 0, 0, 0], [0.01, 1.0e-20, 0.5, 0.0, 0.0])\n\n\n\n\n\n","category":"type"},{"location":"reference/#HSL.Ma57_Info","page":"Reference","title":"HSL.Ma57_Info","text":"Main info type for MA57\n\ninfo = Ma57_Info{T <: Ma97Real}()\n\nAn info variable is used to collect statistics on the analysis, factorization, and solve.\n\nExample:\n\njulia> using HSL\njulia> T = Float64;\njulia> rows = Cint[1, 2, 3, 5, 3, 4, 5]; cols = Cint[1, 1, 2, 2, 3, 3, 5];\njulia> vals = T[2, 3, 4, 6, 1, 5, 1];\njulia> A = sparse(rows, cols, vals);\njulia> M = Ma57(A);\njulia> M.info\nHSL.Ma57_Info{Float64}(Cint[0, 0, 0, 0, 12, 13, 4, 2, 48, 53  …  0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [10.0, 34.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 0, 0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\n\n\n\n\n","category":"type"},{"location":"reference/#HSL.Ma97-Union{Tuple{SparseArrays.SparseMatrixCSC{T, Int64}}, Tuple{T}} where T","page":"Reference","title":"HSL.Ma97","text":"Instantiate and perform symbolic analysis on a sparse Julia matrix\n\nM = Ma97(A; kwargs...)\n\nInstantiate an object of type Ma97 and perform the symbolic analysis on a sparse Julia matrix.\n\nInput arguments\n\nA::SparseMatrixCSC{T,Int}: input matrix. The lower triangle will be extracted.\n\nKeyword arguments\n\nAll keyword arguments are passed directly to ma97_csc().\n\n\n\n\n\n","category":"method"},{"location":"reference/#HSL.Ma97Exception","page":"Reference","title":"HSL.Ma97Exception","text":"Exception type raised in case of error.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HSL.ma97_control-Union{Tuple{}, Tuple{T}} where T","page":"Reference","title":"HSL.ma97_control","text":"Main control type for MA97.\n\nma97_control{T}(; kwargs...)\n\nKeyword arguments:\n\nprint_level::Int: integer controling the verbosit level. Accepted values are:\n<0: no printing\n0: errors and warnings only (default)\n1: errors, warnings and basic diagnostics\n2: errors, warning and full diagnostics\nunit_diagnostics::Int: Fortran file unit for diagnostics (default: 6)\nunit_error::Int: Fortran file unit for errors (default: 6)\nunit_warning::Int: Fortran file unit for warnings (default: 6)\n\n\n\n\n\n","category":"method"},{"location":"reference/#HSL.ma97_info-Union{Tuple{}, Tuple{T}} where T","page":"Reference","title":"HSL.ma97_info","text":"Main info type for MA97\n\ninfo = ma97_info{T}()\n\nAn info structure used to collect statistics on the analysis, factorization and solve.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HSL.kb07","page":"Reference","title":"HSL.kb07","text":"v, perm = kb07(v)\n\nSort an array of numbers v in-place into ascending order maintaining an index array perm to preserve a record of the original order.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.ma57_alter_d","page":"Reference","title":"HSL.ma57_alter_d","text":"Alter block diagonal matrix D\n\nInput arguments:\n\nM::Ma57: Ma57 object\nF::Matrix{Float64}: diagonal adjustment\n\nExample:\n\njulia> using HSL\n\njulia> T = Float64;\n\njulia> rows = Cint[1, 1, 2, 2, 3, 3, 5]; cols = Cint[1, 2, 3, 5, 3, 4, 5];\n\njulia> vals = T[2, 3, 4, 6, 1, 5, 1];\n\njulia> A = sparse(rows, cols, vals); A = A + triu(A, 1)';\n\njulia> b = T[8, 45, 31, 15, 17]\n\njulia> ϵ = sqrt(eps(eltype(A)))\n\njulia> xexact = T[1, 2, 3, 4, 5]\n\njulia> M = Ma57(A)\n\njulia> ma57_factorize(M)\n\njulia> (L, D, s, p) = ma57_get_factors(M)\n\njulia> d1 = abs.(diag(D))\n\njulia> d2 = [diag(D, 1) ; 0]\n\njulia> F = [full(d1)' ; full(d2)']\n\njulia> ma57_alter_d(M, F)\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.ma57_factorize!","page":"Reference","title":"HSL.ma57_factorize!","text":"Factorize Ma57 object in-place.\n\nma57_factorize!(M)\n\nInput arguments:\n\nM::Ma57: Ma57 object\n\nReturn values:\n\nM::Ma57: Ma57 object\n\nExample:\n\n``JULIA julia> using HSL julia> T = Float64; julia> rows = Cint[1, 2, 3, 5, 3, 4, 5]; cols = Cint[1, 1, 2, 2, 3, 3, 5]; julia> vals = T[2, 3, 4, 6, 1, 5, 1]; julia> A = sparse(rows, cols, vals); julia> M = Ma57(A) julia> ma57_factorize!(M)      ## factorizeMa57` object in place\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.ma57_factorize-Union{Tuple{SparseArrays.SparseMatrixCSC{T, Ti}}, Tuple{Ti}, Tuple{T}} where {T<:Union{Float32, Float64}, Ti<:Integer}","page":"Reference","title":"HSL.ma57_factorize","text":"Factorize a sparse matrix.\n\nM = ma57_factorize(A)\n\nInput arguments:\n\nA::SparseMatrixCSC{T<:Ma57Data,Int}: sparse matrix\n\nReturn values:\n\nM::Ma57: factorized Ma57 object\n\nStored information:\n\nM.info.largest_front::Int: order of largest frontal matrix\nM.info.num_2x2_pivots::Int: number of 2x2 pivots used in factorization\nM.info.num_delayed_pivots::Int: total number of fully-summed variables that were passed to the father node because of pivoting considerations\nM.info.num_negative_eigs::Int: number of negative eigenvalues in factorization of A\nM.info.rank::Int: rank of factorization of A\nM.info.num_pivot_sign_changes::Int: number of sign changes of pivot when icntl(7) = 3 (ie, no pivoting)\n\nExample:\n\njulia> using HSL\njulia> T = Float64;\njulia> rows = Cint[1, 2, 3, 5, 3, 4, 5]; cols = Cint[1, 1, 2, 2, 3, 3, 5];\njulia> vals = T[2, 3, 4, 6, 1, 5, 1];\njulia> A = sparse(rows, cols, vals);\njulia> M = ma57_factorize(A)  ## factorize sparse matrix and return `Ma57` object\n\n\n\n\n\n","category":"method"},{"location":"reference/#HSL.ma57_get_factors","page":"Reference","title":"HSL.ma57_get_factors","text":"Retrieve factors, scaling, and permutation.\n\nL, D, s, iperm = ma57getfactors(M)\n\nFunction will retrieve a unit triangular matrix L, a block-diagonal matrix D a scaling   vector s and a permutation vector p such that\n\nP * S * A * S * P' = L * D * L'\n\nwhere S = spdiagm(s) and P = speye(n)[p,:].\n\nNote that the numerical factorization must have been performed and have succeeded.\n\nInput arguments\n\nM::Ma57: factorized Ma57 object\n\nReturn values\n\nL::SparseMatrixCSC{T<:Ma57Data,Int}: L factor\nD::SparseMatrixCSC{T<:Ma57Data,Int}: D factor\ns::Vector{T}: diagonal components of scaling matrix S\niperm::Vector{Int}: array representin permutation matrix P\n\nExample:\n\n\njulia> using HSL\n\njulia> T = Float64;\n\njulia> rows = Cint[1, 1, 2, 2, 3, 3, 5]; cols = Cint[1, 2, 3, 5, 3, 4, 5];\n\njulia> vals = T[2, 3, 4, 6, 1, 5, 1];\n\njulia> A = sparse(rows, cols, vals); A = A + triu(A, 1)';\n\njulia> b = T[8, 45, 31, 15, 17]\n\njulia> ϵ = sqrt(eps(eltype(A)))\n\njulia> xexact = T[1, 2, 3, 4, 5]\n\njulia> M = Ma57(A)\n\njulia> ma57_factorize(M)\n\njulia> (L, D, s, p) = ma57_get_factors(M)\n\njulia> S = spdiagm(s)\n\njulia> P = speye(M.n)[p, :]\n\njulia> vecnorm(P * S * A * S * P' - L * D * L') ≤ ϵ * vecnorm(A)\n\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.ma57_least_squares-Union{Tuple{Ti}, Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{T, Ti}, Array{T}}} where {T<:Union{Float32, Float64}, Ti<:Integer}","page":"Reference","title":"HSL.ma57_least_squares","text":"Solve the least-squares problem     minimize ‖Ax - b‖, where A has shape m-by-n with m > n, by solving the saddle-point system     [ I   A ] [ r ]   [ b ]     [ A'    ] [ x ] = [ 0 ].\n\n\n\n\n\n","category":"method"},{"location":"reference/#HSL.ma57_min_norm-Union{Tuple{Ti}, Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{T, Ti}, Array{T}}} where {T<:Union{Float32, Float64}, Ti<:Integer}","page":"Reference","title":"HSL.ma57_min_norm","text":"Solve the minimum-norm problem     minimize ‖x‖  subject to Ax=b, where A has shape m-by-n with m < n, by solving the saddle-point system     [ I  A' ] [ x ]   [ 0 ]     [ A     ] [ y ] = [ b ].\n\n\n\n\n\n","category":"method"},{"location":"reference/#HSL.ma57_solve","page":"Reference","title":"HSL.ma57_solve","text":"System solve.\n\nSolve after factorization without iterative refinement\n\nma57_solve(ma57, b; kwargs...)\n\nInput arguments:\n\nma57::Ma57{T<:Ma57Data}: an Ma57 structure for which the analysis and factorization have been performed\nb::Array{T}: vector of array of right-hand sides. Note that b will be overwritten. To solve a system with multiple right-hand sides, b should have size n by nrhs.\n\nKeyword arguments:\n\njob::Symbol=:A: task to perform. Accepted values are\n:A: solve Ax = b\n:LS: solve LPSx = PSb\n:DS: solve DPS⁻¹x = PSb\n:LPS: solve L'PS⁻¹x = PS⁻¹b\n\nReturn values:\n\nx::Array{T}: an array of the same size as b containing the solutions.\n\nSolve after factorization with iterative refinement\n\nma57_solve(A, b, nitref; kwargs...)\n\nInput arguments:\n\nA::SparseMatrixCSC{T<:Ma57Data,Int}: input matrix. A full matrix will be converted to sparse.\nb::Array{T}: vector of array of right-hand sides. Note that b will be overwritten. To solve a system with multiple right-hand sides, b should have size n by nrhs.\nnitref::Int: number of iterative refinement steps\n\nReturn values:\n\nx::Array{T}: an array of the same size as b containing the solutions.\n\nStored information:\n\nAccessible through the Ma57 matrix object's `info` attribute\n\nma57.info.backward_error1::T: max{i} |b - Ax|i / (|b| + |A| |x|)_i\nma57.info.backward_error2::T: max{i} |b - Ax|i / ((|A| |x|)i + ||Ai||{∞} ||x||{∞})\nma57.info.matrix_inf_norm::T: ||A||_{∞}\nma57.info.solution_inf_norm::T: ||x||_{∞}\nma57.info.scaled_residuals::T: norm of scaled residuals = max{i} |sumj a{ij} xj - bi| / ||A||{∞} ||x||_{∞})\nma57.info.cond1::T: condition number as defined in Arioli, M. Demmel, J. W., and Duff, I. S. (1989). Solving sparse linear systems with sparse backward error. SIAM J.Matrix Anal. and Applics. 10, 165-190.\nma57.info.cond2::T: condition number as defined in Arioli, M. Demmel, J. W., and Duff, I. S. (1989). Solving sparse linear systems with sparse backward error. SIAM J.Matrix Anal. and Applics. 10, 165-190.\nma57.info.error_inf_norm::T: upper bound for the infinity norm of the error in the solution\n\nExample:\n\njulia> using HSL\njulia> T = Float64;\njulia> rows = Cint[1, 2, 3, 5, 3, 4, 5]; cols = Cint[1, 1, 2, 2, 3, 3, 5];\njulia> vals = T[2, 3, 4, 6, 1, 5, 1];\njulia> A = sparse(rows, cols, vals);\njulia> b = T[8, 45, 31, 15, 17]\njulia> ϵ = sqrt(eps(eltype(A)))\njulia> xexact = T[1, 2, 3, 4, 5]\njulia> M = Ma57(A)\njulia> ma57_factorize!(M)\njulia> x = ma57_solve(M, b)      ## solve without iterative refinement\njulia> norm(x - xexact) ≤ ϵ * norm(xexact)\ntrue\njulia> xx = ma57_solve(M, b, 2)  ## solve with iterative refinement\njulia> norm(xx - xexact) ≤ ϵ * norm(xexact)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.ma57_solve!","page":"Reference","title":"HSL.ma57_solve!","text":"ma57_solve!(ma57, b, work; job::Symbol = :A)\n\nSolve a symmetric linear system ma57 * x = b, overwriting b to store x. work should be a Vector{eltype(b)} of length ma57.n * size(b, 2). The symbolic analysis and numerical factorization must have been performed and must have succeeded.\n\nSolve with iterative refinement\n\nma57_solve!(ma57, b, x, resid, work, nitref)\n\nSolve a symmetric linear system ma57 * x = b  with iterative refinement. ma57.control.icntl[9] should have been set to the maximum number of iterative refinements wanted. resid should be a storage Vector{eltype(b)} of size ma57.n work should be a storage Vector{eltype(b)} of size ma57.n if ma57.control.icntl[9] == 1, and of size 4 * ma57.n otherwise. The symbolic analysis and numerical factorization must have been performed and must have succeeded.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.ma97_coord","page":"Reference","title":"HSL.ma97_coord","text":"Instantiate and perform symbolic analysis using coordinate arrays\n\nM = ma97_coord(n, cols, rows, nzval; kwargs...)\n\nInstantiate an object of type Ma97 and perform the symbolic analysis on a matrix described in sparse coordinate format.\n\nInput arguments\n\nn::Int: the matrix size\ncols::Vector{T<:Integer}: array of column indices for the lower triangle\nrows::Vector{T<:Integer}: array of row indices for the lower triangle\nnzval::Vector{T}: array of values for the lower triangle\n\nKeyword arguments\n\nAll keyword arguments are passed directly to the ma97_control constructor.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.ma97_csc","page":"Reference","title":"HSL.ma97_csc","text":"Instantiate and perform symbolic analysis using CSC arrays\n\nM = ma97_csc(n, colptr, rowval, nzval; kwargs...)\n\nInstantiate an object of type Ma97 and perform the symbolic analysis on a matrix described in sparse CSC format.\n\nInput arguments\n\nn::Int: the matrix size\ncolptr::Vector{T<:Integer}: CSC colptr array for the lower triangle\nrowval::Vector{T<:Integer}: CSC rowval array for the lower triangle\nnzval::Vector{T}: CSC nzval array for the lower triangle\n\nKeyword arguments\n\nAll keyword arguments are passed directly to the ma97_control constructor.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.ma97_enquire","page":"Reference","title":"HSL.ma97_enquire","text":"ma97enquire: see the documentation for `ma97inquire`.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.ma97_factorise","page":"Reference","title":"HSL.ma97_factorise","text":"ma97factorise: see the documentation for `ma97factorize`.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.ma97_factorise!","page":"Reference","title":"HSL.ma97_factorise!","text":"ma97factorise!: see the documentation for `ma97factorize!`.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.ma97_factorize","page":"Reference","title":"HSL.ma97_factorize","text":"Combined Analysis and factorization\n\nM = ma97_factorize(A; kwargs...)\n\nConvenience method that combines the symbolic analysis and numerical factorization phases. An MA97 instance is returned, that can subsequently be passed to other functions, e.g., ma97_solve().\n\nInput Arguments\n\nA::SparseMatrixCSC{T,Int}: Julia sparse matrix\n\nKeyword Arguments\n\nmatrix_type::Symbol=:real_indef: indicates the matrix type. Accepted values are\n:real_spd for a real symmetric and positive definite matrix\n:real_indef for a real symmetric and indefinite matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.ma97_factorize!","page":"Reference","title":"HSL.ma97_factorize!","text":"Perform numerical factorization.\n\nma97_factorize!(ma97; kwargs...)\n\nThe symbolic analysis must have been performed and must have succeeded.\n\nInput Arguments\n\nma97::Ma97{T}: an Ma97 structure for which the analysis has been performed\n\nKeyword Arguments\n\nmatrix_type::Symbol=:real_indef: indicates the matrix type. Accepted values are\n:real_spd for a real symmetric and positive definite matrix\n:real_indef for a real symmetric and indefinite matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.ma97_inquire","page":"Reference","title":"HSL.ma97_inquire","text":"Inquire about a factorization or solve\n\nma97_inquire(ma97; kwargs...)\n\nObtain information on the pivots after a successful factorization or solve.\n\nInput Arguments\n\nma97::Ma97{T}: an Ma97 structure for which the analysis and factorization have been performed\n\nKeyword arguments\n\nmatrix_type::Symbol=:real_indef: indicates the matrix type. Accepted values are\n:real_spd for a real symmetric and positive definite matrix\n:real_indef for a real symmetric and indefinite matrix.\n\nReturn values\n\nAn inquiry on a real or complex indefinite matrix returns two vectors:\n\npiv_order: contains the pivot sequence; a negative value indicates that the corresponding variable is part of a 2x2 pivot,\nd: a 2 by n array whose first row contains the diagonal of D⁻¹ in the factorization, and whose nonzeros in the second row contain the off-diagonals.\n\nAn inquiry on a positive definite matrix returns one vector with the pivot values.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.ma97_least_squares-Union{Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{T, Int64}, Vector{T}}} where T","page":"Reference","title":"HSL.ma97_least_squares","text":"Solve least-squares problem\n\nma97_least_squares(A, b)\n\nSolve the least-squares problem\n\nminimize ‖Ax - b‖₂\n\nwhere A has shape m-by-n with m > n, by solving the saddle-point system\n\n[ I   A ] [ r ]   [ b ]\n[ Aᴴ    ] [ x ] = [ 0 ].\n\nInput arguments\n\nA::SparseMatrixCSC{T,Int}: input matrix of shape m-by-n with m > n. A full matrix will be converted to sparse.\nb::Vector{T}: right-hand side vector\n\nReturn value\n\nx::Vector{T}: solution vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HSL.ma97_min_norm-Union{Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{T, Int64}, Vector{T}}} where T","page":"Reference","title":"HSL.ma97_min_norm","text":"Solve a minimum-norm problem\n\nma97_min_norm(A, b)\n\nsolves\n\nminimize ‖x‖₂  subject to Ax = b,\n\nwhere A has shape m-by-n with m < n, by solving the saddle-point system\n\n[ I  Aᴴ ] [ x ]   [ 0 ]\n[ A     ] [ y ] = [ b ].\n\nInput arguments\n\nA::SparseMatrixCSC{T,Int}: input matrix of shape m-by-n with m < n. A full matrix will be converted to sparse.\nb::Vector{T}: right-hand side vector.\n\nReturn value\n\nx::Vector{T}: solution vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HSL.ma97_solve","page":"Reference","title":"HSL.ma97_solve","text":"System solve\n\nSolve after factorization\n\nma97_solve(ma97, b; kwargs...)\n\nInput arguments\n\nma97::Ma97{T}: an Ma97 structure for which the analysis and factorization have been performed\nb::Array{T}: vector of array of right-hand sides. Note that b will be overwritten. To solve a system with multiple right-hand sides, b should have size n by nrhs.\n\nKeyword arguments\n\njob::Symbol=:A: task to perform. Accepted values are\n:A: solve Ax = b\n:PL: solve PLx = Sb\n:D: solve Dx = b\n:LPS: solve L'P'S⁻¹x = b\n:DLPS: solve DL'P'S⁻¹x = b.\n\nReturn values\n\nx::Array{T}: an array of the same size as b containing the solutions.\n\nCombined analysis, factorization and solve\n\nma97_solve(A, b; kwargs...)\n\nInput arguments\n\nA::SparseMatrixCSC{T,Int}: input matrix. A full matrix will be converted to sparse.\nb::Array{T}: vector of array of right-hand sides. Note that b will be overwritten. To solve a system with multiple right-hand sides, b should have size n by nrhs.\n\nKeyword arguments\n\nmatrix_type::Symbol=:real_indef: indicates the matrix type. Accepted values are\n:real_spd for a real symmetric and positive definite matrix\n:real_indef for a real symmetric and indefinite matrix.\n\nReturn values\n\nx::Array{T}: an array of the same size as b containing the solutions.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.ma97_solve!","page":"Reference","title":"HSL.ma97_solve!","text":"In-place system solve\n\nSee the documentation for ma97_solve(). The only difference is that the right-hand side b is overwritten with the solution.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HSL.mc21-Tuple{SparseArrays.SparseMatrixCSC}","page":"Reference","title":"HSL.mc21","text":"p = mc21(A::SparseMatrixCSC; sym::Bool=false)\n\nGiven a sparse matrix A, this function attempts to find a column permutation p that makes the matrix A[:,p] have nonzeros on its diagonal.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HSL.mc77","page":"Reference","title":"HSL.mc77","text":"mc77(A::SparseMatrixCSC{T}, job::Integer)\nmc77(A::Matrix{T}, job::Integer)\nmc77(m::Integer, n::Integer, rows::Vector{Int32}, cols::Vector{Int32}, nzval::Vector{T}, job::Integer)\n\njob=0 Equilibrate the infinity norm of rows and columns in matrix A.\njob=p Equilibrate the p-th norm (p ≥ 1) of rows and columns in A.\njob=-1 Equilibrate the p-th norm of rows and columns in A, with p ≥ 1 real. The value of p is given in CNTL[2].\n\nLet A be an m × n real matrix, and ‖•‖ₚ, p ∈ [1, ∞] a p-norm for real vectors. mc77 computes the scaling diagonal matrices Dr and Dc such that the p-norms of all columns and rows of A̅ = (Dr)⁻¹A(Dc)⁻¹ are approximately equal to 1.\n\nWhen A is symmetric Dr = Dc. In the case m ≠ n, mc77 allows the use of the ∞-norm only.\n\n\n\n\n\n","category":"function"},{"location":"#Home","page":"Home","title":"HSL.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A set of interfaces to HSL packages for sparse linear algebra.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Certain HSL packages are freely available to all, others are freely available to academics only. Please refer to the website above for licensing information. In all cases, users are responsible for obtaining HSL packages.","category":"page"},{"location":"#Installing","page":"Home","title":"Installing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add HSL","category":"page"},{"location":"","page":"Home","title":"Home","text":"At this point, make sure that there isn't a stray METIS library on your library path. You especially want to make sure that METIS 5 is not accessible because the HSL library currently interfaced only supports METIS 4. If you have such library accessible, it is important to remove it from the library path, at least temporarily. For example, if you are on OSX and are using Homebrew, you can hide METIS 5 with brew unlink metis. After the install procedure is complete, it is fine to link metis again with brew link metis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Set the environment variables HSL_MA57_PATH and HSL_MA97_PATH to specify where the source archives tar.gz are stored. Alternatively, you can use the zip archive as long as unzip is installed on your system. The HSL Julia module will take care of compilation. Once the source archives have been placed in the locations indicated by the environment variables, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> build HSL\npkg> test HSL","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that a C and Fortran compilers are required. Should it be necessary, you can set the compilers to use by setting the environment variables","category":"page"},{"location":"","page":"Home","title":"Home","text":"HSL_FC: the Fortran 90/95 compiler (default: gfortran)\nHSL_F77: the Fortran 77 compiler (default: the same as FC)\nHSL_CC: the C compiler (default: gcc).","category":"page"},{"location":"#General-Guidelines-on-Compilers","page":"Home","title":"General Guidelines on Compilers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The version of gcc and gfortran used to compile HSL.jl should be based on the same version of the shared libgfortran library as the version of Julia being used. On Linux, Julia ≥ 1.8 is based on libgfortran version 5, whereas on macOS, they are based on libgfortran version 4. Thus for instance, versions of gcc/gfortran as recent as 11 are appropriate on Linux, but version 7 could be used on macOS. On macOS, the compilers can be installed with Homebrew using","category":"page"},{"location":"","page":"Home","title":"Home","text":"brew install gcc@7","category":"page"},{"location":"#Installing-on-Apple-Silicon","page":"Home","title":"Installing on Apple Silicon","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Homebrew does not (yet) provide precompiled binaries for gcc/gfortran based on libgfortran version 4. One solution is to use Julia and the compilers built for Intel Macs via Rosetta. First make sure that Rosetta is installed by following, e.g., these instructions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You may now install Homebrew for Intel Macs on your Silicon Mac:","category":"page"},{"location":"","page":"Home","title":"Home","text":"arch -x86_64 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that Homebrew for Silicon installs in /opt/homebrew whereas Homebrew for Intel installs in /usr/local.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next, install gcc/gfortran version 7 for Intel:","category":"page"},{"location":"","page":"Home","title":"Home","text":"arch -x86_64 /usr/local/bin/brew install gcc@7","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, define the environment variables","category":"page"},{"location":"","page":"Home","title":"Home","text":"HSL_FC=/usr/local/bin/gfortran-7 -arch x86_64\nHSL_CC=/usr/local/bin/gcc-7 -arch x86_64","category":"page"},{"location":"","page":"Home","title":"Home","text":"prior to building HSL.jl from the Julia command prompt.","category":"page"},{"location":"#Supported-Packages","page":"Home","title":"Supported Packages","text":"","category":"section"},{"location":"#HSL_MA97","page":"Home","title":"HSL_MA97","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Supported versions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"2.6.0\n2.7.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"HSL_MA97: an OpenMP-based direct solver for symmetric linear systems. Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MatrixMarket\nusing HSL\n\nK = MatrixMarket.mmread(\"K.mtx\")  # only the lower triangle\nrhs = readdlm(\"rhs.rhs\")\n\nLBL = Ma97(K)\nma97_factorize!(LBL)\nx = ma97_solve(LBL, rhs)  # or x = LBL \\ rhs","category":"page"},{"location":"#Rectangular-Systems","page":"Home","title":"Rectangular Systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There is a convenience interface to solve rectangular systems that complements the sparse QR factorization in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When A is m-by-n with m < n and has full row rank,","category":"page"},{"location":"","page":"Home","title":"Home","text":"(x, y) = ma97_solve(A, b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"solves for the minimum-norm solution, i.e., x such that Ax = b and x + Aᵀ y = 0. The call","category":"page"},{"location":"","page":"Home","title":"Home","text":"(x, y) = ma97_min_norm(A, b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"is also defined, and is equivalent to the above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When m > n and has full column rank,","category":"page"},{"location":"","page":"Home","title":"Home","text":"(r, x) = ma97_solve(A, b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"solves for the least-squares solution, i.e., x such that r = b - Ax satisfies Aᵀ r = 0. The call","category":"page"},{"location":"","page":"Home","title":"Home","text":"(r, x) = ma97_least_squares(A, b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"is also defined, and is equivalent to the above.","category":"page"},{"location":"#HSL_MA57","page":"Home","title":"HSL_MA57","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HSL_MA57 version 5.2.0: a sparse, multifrontal solver for symmetric linear systems. Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MatrixMarket\nusing HSL\n\nK = MatrixMarket.mmread(\"examples/K_0.mtx\")  # only the lower triangle\nrhs = readdlm(\"examples/rhs_0.rhs\")\nrhss = hcat(rhs, rhs)\n\n## factorize and solve\nLDL = Ma57(K)\nma57_factorize!(LDL)\nLDL.info.rank\nx = ma57_solve(LDL, rhs)  # or x = LBL \\ rhs\nnorm(K*x - rhs)\nxx = ma57_solve(LDL, rhss)  # or x = LBL \\ rhss","category":"page"},{"location":"#Rectangular-Systems-2","page":"Home","title":"Rectangular Systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There is a convenience interface to solve rectangular systems that complements the sparse QR factorization in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When A is m-by-n with m < n and has full row rank,","category":"page"},{"location":"","page":"Home","title":"Home","text":"(x, y) = ma57_solve(A, b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"solves for the minimum-norm solution, i.e., x such that Ax = b and x + Aᵀ y = 0. The call","category":"page"},{"location":"","page":"Home","title":"Home","text":"(x, y) = ma57_min_norm(A, b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"is also defined, and is equivalent to the above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When m > n and has full column rank,","category":"page"},{"location":"","page":"Home","title":"Home","text":"(r, x) = ma57_solve(A, b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"solves for the least-squares solution, i.e., x such that r = b - Ax satisfies Aᵀ r = 0. The call","category":"page"},{"location":"","page":"Home","title":"Home","text":"(r, x) = ma57_least_squares(A, b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"is also defined, and is equivalent to the above. Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MatrixMarket\nusing HSL\n\nK = MatrixMarket.mmread(\"examples/K_0.mtx\")  # only the lower triangle\nrhs = readdlm(\"examples/rhs_0.rhs\")\n\n## solve min norm\nK_mn = K[1:200,:]\nx_mn, y_mn = ma57_min_norm(K_mn, rhs[1:200]) # == ma57_solve(K_mn, rhs[1:200])\n\n## solve least squares\nK_ls = K[:,1:200]\nr_ls, x_ls = ma57_least_squares(K_ls, rhs)   # == ma57_solve(K_ls, rhs)","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"HSL MA57 and MA97 can be used for the solution of symmetric, possibly indefinite, linear systems. They are often used for the solution of saddle-point systems, i.e., systems of the form","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginequation\n  labelSP\n  beginbmatrix\n    -H  A^T \n     A  G\n  endbmatrix\n  beginbmatrix\n    x  y\n  endbmatrix\n  =\n  beginbmatrix\n    c  b\n  endbmatrix\nendequation","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A special case occurs when H = 0, G = I and c = 0, which corresponds to the least-squares problem","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginequation\n  labelLS\n  min_x  A x - b_2\nendequation","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Another special case occurs when H = -I, G = 0 and c = 0, which corresponds to the least-norm problem","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginequation\n  labelLN\n  min_x  x  textsubject to  Ax = b\nendequation","category":"page"},{"location":"tutorial/#HSL_MA97","page":"Tutorial","title":"HSL_MA97","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Supported versions:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"2.6.0\n2.7.0","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"HSL_MA97: an OpenMP-based direct solver for symmetric linear systems. Example:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using MatrixMarket\nusing HSL\n\nK = MatrixMarket.mmread(\"K.mtx\")  # only the lower triangle\nrhs = readdlm(\"rhs.rhs\")\n\nLBL = Ma97(K)\nma97_factorize!(LBL)\nx = ma97_solve(LBL, rhs)  # or x = LBL \\ rhs","category":"page"},{"location":"tutorial/#Rectangular-Systems","page":"Tutorial","title":"Rectangular Systems","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There is a convenience interface to solve rectangular systems that complements the sparse QR factorization in Julia.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When A is m-by-n with m geq n and has full column rank,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(r, x) = ma97_solve(A, b)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"returns x that solves \\eqref{LS} and residual r = b - Ax corresponding to y in \\eqref{SP}. The call","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(r, x) = ma97_least_squares(A, b)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"is also defined, and is equivalent to the above.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When A is m-by-n with m leq n and has full row rank,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(x, y) = ma97_solve(A, b)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"returns x that solves \\eqref{LN} and y such that x = -A^T y (and therefore A A^T (-y) = b). The call","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(x, y) = ma97_min_norm(A, b)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"is also defined, and is equivalent to the above.","category":"page"},{"location":"tutorial/#HSL_MA57","page":"Tutorial","title":"HSL_MA57","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"HSL_MA57 version 5.2.0: a sparse, multifrontal solver for symmetric linear systems. Example:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using MatrixMarket\nusing HSL\n\nK = MatrixMarket.mmread(\"examples/K_0.mtx\")  # only the lower triangle\nrhs = readdlm(\"examples/rhs_0.rhs\")\nrhss = hcat(rhs, rhs)\n\n## factorize and solve\nLDL = Ma57(K)\nma57_factorize(LDL)\nLDL.info.rank\nx = ma57_solve(LDL, rhs)  # or x = LBL \\ rhs\nnorm(K*x - rhs)\nxx = ma57_solve(LDL, rhss)  # or x = LBL \\ rhss","category":"page"},{"location":"tutorial/#Rectangular-Systems-2","page":"Tutorial","title":"Rectangular Systems","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There is a convenience interface to solve rectangular systems that complements the sparse QR factorization in Julia.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When A is m-by-n with m geq n and has full column rank,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(r, x) = ma57_solve(A, b)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"returns x that solves \\eqref{LS} and residual r = b - Ax corresponding to y in \\eqref{SP}. The call","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(r, x) = ma57_least_squares(A, b)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"is also defined, and is equivalent to the above.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When A is m-by-n with m leq n and has full row rank,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(x, y) = ma57_solve(A, b)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"returns x that solves \\eqref{LN} and y such that x = -A^T y (and therefore A A^T (-y) = b). The call","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(x, y) = ma57_min_norm(A, b)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"is also defined, and is equivalent to the above. Example:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using MatrixMarket\nusing HSL\n\nK = MatrixMarket.mmread(\"examples/K_0.mtx\")  # only the lower triangle\nrhs = readdlm(\"examples/rhs_0.rhs\")\n\n## solve min norm\nK_mn = K[1:200,:]\nx_mn, y_mn = ma57_min_norm(K_mn, rhs[1:200]) # == ma57_solve(K_mn, rhs[1:200])\n\n## solve least squares\nK_ls = K[:,1:200]\nr_ls, x_ls = ma57_least_squares(K_ls, rhs)   # == ma57_solve(K_ls, rhs)","category":"page"}]
}
