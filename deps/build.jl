using BinaryProvider, SHA # requires BinaryProvider 0.3.0 or later

using METIS4_jll
using OpenBLAS32_jll

include("custom_build_functions.jl")

struct HSLVersion
  algname::String
  version::String
  sha::String
  ext::String
  buildfun::Function
end
function HSLVersion(algname::String, version::String, sha::String; ext=".tar.gz", buildfun=buildlib)
  HSLVersion(algname, version, sha, ext, buildfun)
end

getname(ver::HSLVersion, extension::Bool=true) = ver.algname * "-" * ver.version * (extension ? ver.ext : "")

function checksha(version::HSLVersion, filepath)
  if isfile(filepath)
    open(filepath) do f
      return bytes2hex(sha256(f)) == version.sha 
    end
  else
    return false
  end
end

"""
Find a version of an algorithm whose archive is in one of the search paths.
Searches ./downloads, ENV["HSL_ARCHIVES_PATH"] and ENV["<ALGNAME>_PATH], e.g.
"HSL_MA97_PATH" or "COINHSL_PATH"

Returns a named tuple `(ver,archive)` with the HSLVersion for the version that was found, 
  along with the path of the archive
"""
function findversion(versions::Vector{HSLVersion}) 
  isempty(versions) && (return (ver=nothing, archive="") 
  )
  algname = versions[1].algname
  
  # Search paths, in order of priority
  paths = [  
  joinpath(@__DIR__, "downloads"),
  ]
  haskey(ENV,"HSL_ARCHIVES_PATH") && push!(paths, ENV["HSL_ARCHIVES_PATH"])
  haskey(ENV,"$(uppercase(algname))_PATH") && push!(paths, ENV["$(uppercase(algname))_PATH"])
  
  # Search each version and path until an archive is found
  for ver in versions
    @assert ver.algname == algname "All versions must have the same name."
    archivename = getname(ver) 
    for path in paths
      archivepath = joinpath(path, archivename)
      if isfile(archivepath)
        @info "Found archive for $algname at $archivepath"
        if checksha(ver, archivepath)
          return (ver=ver, archive=archivepath)
        else
          error("Archive found but didn't match SHA for $(ver.algname).")
        end
      end
    end
  end
  return (ver=nothing, archive="") 
end

"""
Default build function for an HSL library. Should return a vector of 
  `BinaryProvider::Product`s that should be generated by the build.
"""
function buildlib(ver::HSLVersion, archive::AbstractString)
  so         = Sys.isapple() ? "dylib" : "so"
  all_load   = Sys.isapple() ? "-all_load" : "--whole-archive"
  noall_load = Sys.isapple() ? "-noall_load" : "--no-whole-archive"

  libname = "lib" * ver.algname
  fp = FileProduct(prefix, "lib/$libname.$so", Symbol(libname))

  # Extract the archive
  if ver.ext == ".tar.gz"
    run(`tar -zxf $archive -C $builddir`)
  elseif ver.ext == ".zip"
    run(`unzip -o $archive -d $builddir`)
  end
  
  # Build library
  name = getname(ver, false)  # get name with version but without extension
  cd("$builddir/$name")
  run(`./configure --prefix=$usrdir F77=gfortran CFLAGS=-fPIC FFLAGS="-fPIC -fopenmp" FCFLAGS="-fPIC -fopenmp" --with-blas="-L$libopenblas_dir -lopenblas" --with-metis="-L$libmetis_dir -lmetis"`)
  run(`make install`)
  run(`gfortran -fPIC -shared -Wl,$all_load $libdir/lib$(ver.algname).a -L$libopenblas_dir -lopenblas -L$libmetis_dir -lmetis -lgomp -Wl,$noall_load -o $libdir/lib$(ver.algname).$so`)
  cd(@__DIR__)
  return [fp]
end

# Parse some basic command-line arguments
const verbose = "--verbose" in ARGS
const prefix = Prefix(get([a for a in ARGS if a != "--verbose"], 1, joinpath(@__DIR__, "usr")))

##############################
# MA57
##############################
const hsl_ma57_versions = [
HSLVersion("hsl_ma57", "5.2.0", "aedc5a3e22a7b86779efccaa89a7c82b6949768dbab35fceb85a347e326cf584", buildfun=buildma57),
]

##############################
# MA97
##############################
const hsl_ma97_versions = [
HSLVersion("hsl_ma97", "2.7.0", "ac3a081d3a28e9ecb8871ce769f4ced2a5ffa5a9c36defbd2c844ae3493ccb37"),
HSLVersion("hsl_ma97", "2.7.0", "8221b607d96554d7a57cc60483c7305ef43a8785dc4171ac2e8da087900a1100", ext=".zip"),
HSLVersion("hsl_ma97", "2.6.0", "be5fe822674be93e3d2e1a7d7ed6c5ad831b91cf8ca5150beb473f67af5fcb66")
]

##############################
# COINHSL
##############################
const hsl_coin_versions = [
# HSLVersion("coinhsl", "2021.05.05", "f77ad752a37de8695c02c81bcc503674af76689d40a9864b6f2a7a790c3efc95", ".tar.gz"),  # this has a problem with the install-sh script
HSLVersion("coinhsl", "2021.05.05", "62c7e18ff22b977afa442db97d791f31359ab4a4f5a027f315cace211a24fbe9", ext=".zip", buildfun=build_coinhsl)
]

##############################
# Build
##############################
# For new algorithms, add their list of versions here
const hsl_algorithms = [hsl_ma57_versions, hsl_ma97_versions, hsl_coin_versions]

const hsl_algorithms_found = filter(x->!isnothing(x.ver), findversion.(hsl_algorithms))

if !isempty(hsl_algorithms_found)
  products = Product[]
  
  libopenblas_dir=joinpath(OpenBLAS32_jll.artifact_dir, "lib")
  libmetis_dir=joinpath(METIS4_jll.artifact_dir, "lib")
  
  usrdir = joinpath(@__DIR__, "usr")
  libdir = joinpath(usrdir, "lib")
  builddir = joinpath(usrdir, "src")
  mkpath(builddir)

  for alg in hsl_algorithms_found
    algname = alg.ver.algname
    @info "Building $algname"

    # Call the build function for the version
    expected_products = alg.ver.buildfun(alg.ver, alg.archive)
    append!(products, expected_products)
  end
  
  @assert(all(satisfied.(products)))
  
  # Write out a deps.jl file that will contain mappings for our products
  write_deps_file(joinpath(@__DIR__, "deps.jl"), products, verbose=verbose)
else
  @info "No archive found."
  write_deps_file(joinpath(@__DIR__, "deps.jl"), Product[], verbose=verbose)
end
